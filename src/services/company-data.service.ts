// Service orchestrateur pour les donn√©es d'entreprise
// Combine INSEE, LinkedIn et autres sources

import { inseeService } from './insee.service';
import { linkedInService } from './linkedin.service';

import type {
    CompanySearchParams,
    CompanySearchResult,
    EnrichedCompany,
    INSEECompany,
    SearchFilters
} from '../types/company';

export class CompanyDataService {
  /**
   * Teste la connexion aux services externes
   */
  async testConnections(): Promise<{
    insee: { success: boolean; message: string };
    linkedin: { success: boolean; message: string };
  }> {
    const [inseeResult] = await Promise.allSettled([
      inseeService.testConnection(),
    ]);

    return {
      insee: inseeResult.status === 'fulfilled' 
        ? inseeResult.value 
        : { success: false, message: 'Erreur de test INSEE' },
      linkedin: { success: true, message: 'Service LinkedIn disponible (simulation)' },
    };
  }

  /**
   * Alias pour compatibilit√© avec l'ancien service
   */
  async testInseeConnection(): Promise<{ success: boolean; message: string }> {
    const results = await this.testConnections();
    return results.insee;
  }

  /**
   * R√©cup√®re tous les r√©sultats d'une recherche (pour compatibilit√©)
   */
  async getAllSearchResults(params: any): Promise<{ companies: INSEECompany[]; total: number }> {
    return await inseeService.getAllSearchResults(params);
  }

  /**
   * Recherche d'entreprises (pour compatibilit√©)
   */
  async searchCompanies(params: any): Promise<{ companies: INSEECompany[]; total: number }> {
    const result = await inseeService.searchCompanies(params);
    return {
      companies: result.companies,
      total: result.total,
    };
  }

  /**
   * Enrichissement LinkedIn (pour compatibilit√©)
   */
  async enrichWithLinkedIn(companies: INSEECompany[]): Promise<EnrichedCompany[]>;
  async enrichWithLinkedIn(domain: string): Promise<any>;
  async enrichWithLinkedIn(input: INSEECompany[] | string): Promise<EnrichedCompany[] | any> {
    if (typeof input === 'string') {
      // Enrichissement d'un domaine sp√©cifique
      return await linkedInService.enrichWithLinkedIn([{ domain: input } as any]);
    } else {
      // Enrichissement d'un tableau d'entreprises
      return await linkedInService.enrichWithLinkedIn(input);
    }
  }

  /**
   * Calcule un score de ciblage pour une entreprise
   */
  calculateTargetingScore(company: any, criteria: any = {}): number {
    let score = 0;
    
    // Score bas√© sur la taille
    if (company.trancheEffectifs) {
      score += this.getEmployeeSizeScore(company.trancheEffectifs);
    }
    
    // Score bas√© sur l'activit√©
    if (criteria.targetSectors && company.activitePrincipale) {
      const isTargetSector = criteria.targetSectors.includes(company.activitePrincipale);
      score += isTargetSector ? 30 : 0;
    }
    
    // Score bas√© sur la localisation
    if (criteria.targetRegions && company.adresse?.codePostal) {
      const region = this.getRegionFromPostalCode(company.adresse.codePostal);
      const isTargetRegion = criteria.targetRegions.includes(region);
      score += isTargetRegion ? 20 : 0;
    }
    
    return Math.min(score, 100);
  }

  /**
   * G√©n√®re des tags pour une entreprise
   */
  generateTags(company: any): string[] {
    const tags: string[] = [];
    
    // Tags bas√©s sur la taille
    if (company.trancheEffectifs) {
      tags.push(this.getSizeTag(company.trancheEffectifs));
    }
    
    // Tags bas√©s sur l'activit√©
    if (company.activitePrincipaleLibelle) {
      tags.push(this.getActivityTag(company.activitePrincipaleLibelle));
    }
    
    // Tags bas√©s sur la localisation
    if (company.adresse?.codePostal) {
      const region = this.getRegionFromPostalCode(company.adresse.codePostal);
      tags.push(region);
    }
    
    // Tag pour l'√©tat
    if (company.etatAdministratif === 'A') {
      tags.push('Actif');
    }
    
    return tags;
  }

  /**
   * Valide un num√©ro SIREN
   */
  isValidSiren(siren: string): boolean {
    return /^\d{9}$/.test(siren);
  }

  /**
   * Valide un num√©ro SIRET
   */
  isValidSiret(siret: string): boolean {
    return /^\d{14}$/.test(siret);
  }

  // M√©thodes priv√©es pour les calculs
  private getEmployeeSizeScore(trancheEffectifs: string): number {
    const sizeScores: Record<string, number> = {
      '00': 5,   // Aucun salari√©
      '01': 10,  // 1-2 salari√©s
      '02': 15,  // 3-5 salari√©s
      '03': 20,  // 6-9 salari√©s
      '11': 25,  // 10-19 salari√©s
      '12': 30,  // 20-49 salari√©s
      '21': 35,  // 50-99 salari√©s
      '22': 40,  // 100-199 salari√©s
      '31': 45,  // 200-249 salari√©s
      '32': 50,  // 250-499 salari√©s
    };
    return sizeScores[trancheEffectifs] || 25;
  }

  private getSizeTag(trancheEffectifs: string): string {
    const sizeTags: Record<string, string> = {
      '00': 'Ind√©pendant',
      '01': 'Tr√®s Petite Entreprise',
      '02': 'Tr√®s Petite Entreprise',
      '03': 'Tr√®s Petite Entreprise',
      '11': 'Petite Entreprise',
      '12': 'Petite Entreprise',
      '21': 'Moyenne Entreprise',
      '22': 'Moyenne Entreprise',
      '31': 'Grande Entreprise',
      '32': 'Grande Entreprise',
    };
    return sizeTags[trancheEffectifs] || 'Taille inconnue';
  }

  private getActivityTag(activite: string): string {
    if (activite.toLowerCase().includes('commerce')) return 'Commerce';
    if (activite.toLowerCase().includes('conseil')) return 'Conseil';
    if (activite.toLowerCase().includes('informatique')) return 'Tech';
    if (activite.toLowerCase().includes('construction')) return 'BTP';
    if (activite.toLowerCase().includes('restauration')) return 'Restauration';
    return 'Autre secteur';
  }

  /**
   * Recherche unifi√©e d'entreprises avec enrichissement optionnel
   */
  async searchCompaniesUnified(
    params: CompanySearchParams & {
      enrichWithLinkedIn?: boolean;
      getAllResults?: boolean;
    }
  ): Promise<{
    companies: INSEECompany[] | EnrichedCompany[];
    total: number;
    page?: number;
    totalPages?: number;
  }> {
    console.log('üîç Recherche unifi√©e avec param√®tres:', params);

    // Recherche INSEE
    const searchResult = params.getAllResults
      ? await inseeService.getAllSearchResults(params)
      : await inseeService.searchCompanies(params);

    let companies: INSEECompany[] | EnrichedCompany[] = searchResult.companies;

    // Enrichissement LinkedIn optionnel
    if (params.enrichWithLinkedIn && companies.length > 0) {
      console.log('üîó Enrichissement LinkedIn activ√©');
      companies = await linkedInService.enrichWithLinkedIn(companies);
    }

    return {
      companies,
      total: searchResult.total,
      page: searchResult.page,
      totalPages: searchResult.totalPages,
    };
  }

  /**
   * Recherche d'entreprises par dirigeant
   */
  async searchCompaniesByDirigeant(params: {
    nom?: string;
    prenom?: string;
    qualite?: string;
    enrichWithLinkedIn?: boolean;
  }): Promise<{
    companies: INSEECompany[] | EnrichedCompany[];
    total: number;
  }> {
    console.log('üë§ Recherche par dirigeant:', params);

    // Construction de la requ√™te pour rechercher par dirigeant
    // Note: L'API INSEE ne fournit pas directement les donn√©es dirigeants
    // Cette fonction est pr√©par√©e pour une future int√©gration
    
    const queryParts: string[] = [];
    
    if (params.nom) {
      queryParts.push(`dirigeant:"${params.nom}"`);
    }
    
    if (params.prenom) {
      queryParts.push(`dirigeant:"${params.prenom}"`);
    }

    // Pour l'instant, on fait une recherche classique
    // En attendant une API d√©di√©e aux dirigeants
    const searchParams: CompanySearchParams = {
      q: queryParts.join(' AND ') || params.nom || '',
    };

    const result = await this.searchCompaniesUnified({
      ...searchParams,
      enrichWithLinkedIn: params.enrichWithLinkedIn,
    });

    return result;
  }

  /**
   * Recherche avanc√©e avec filtres multiples
   */
  async searchWithFilters(
    searchQuery: string,
    filters: SearchFilters,
    options: {
      page?: number;
      limit?: number;
      enrichWithLinkedIn?: boolean;
    } = {}
  ): Promise<CompanySearchResult | { companies: EnrichedCompany[]; total: number; page?: number; totalPages?: number; }> {
    console.log('üîé Recherche avec filtres:', { searchQuery, filters, options });

    // Construction des param√®tres de recherche
    const searchParams: CompanySearchParams = {
      q: searchQuery,
      page: options.page || 1,
      nombre: options.limit || 20,
    };

    // Application des filtres
    if (filters.regions && filters.regions.length > 0) {
      // Les r√©gions peuvent √™tre converties en codes d√©partement
      // Pour simplifier, on prend la premi√®re r√©gion
      searchParams.region = filters.regions[0];
    }

    if (filters.legalForms && filters.legalForms.length > 0) {
      // Les formes juridiques ont des codes sp√©cifiques
      searchParams.categorieJuridique = filters.legalForms[0];
    }

    if (filters.sectors && filters.sectors.length > 0) {
      // Les secteurs correspondent aux codes d'activit√©
      searchParams.activitePrincipale = filters.sectors[0];
    }

    return await this.searchCompaniesUnified({
      ...searchParams,
      enrichWithLinkedIn: options.enrichWithLinkedIn,
    });
  }

  /**
   * Obtient les statistiques d'une recherche
   */
  async getSearchStatistics(
    params: CompanySearchParams
  ): Promise<{
    total: number;
    byRegion: Record<string, number>;
    bySector: Record<string, number>;
    bySize: Record<string, number>;
    byLegalForm: Record<string, number>;
  }> {
    console.log('üìä Calcul des statistiques pour:', params);

    // R√©cup√©ration d'un √©chantillon pour calculer les statistiques
    const sampleResult = await inseeService.searchCompanies({
      ...params,
      nombre: 1000, // √âchantillon plus large
    });

    const companies = sampleResult.companies;
    
    // Calcul des statistiques
    const byRegion: Record<string, number> = {};
    const bySector: Record<string, number> = {};
    const bySize: Record<string, number> = {};
    const byLegalForm: Record<string, number> = {};

    companies.forEach(company => {
      // Par r√©gion (bas√© sur le code postal)
      const region = this.getRegionFromPostalCode(company.adresse.codePostal);
      byRegion[region] = (byRegion[region] || 0) + 1;

      // Par secteur
      const sector = company.activitePrincipaleLibelle || 'Non sp√©cifi√©';
      bySector[sector] = (bySector[sector] || 0) + 1;

      // Par taille
      const size = this.getSizeLabel(company.trancheEffectifs);
      bySize[size] = (bySize[size] || 0) + 1;

      // Par forme juridique
      const legalForm = company.categorieJuridique || 'Non sp√©cifi√©';
      byLegalForm[legalForm] = (byLegalForm[legalForm] || 0) + 1;
    });

    return {
      total: sampleResult.total,
      byRegion,
      bySector,
      bySize,
      byLegalForm,
    };
  }

  /**
   * D√©termine la r√©gion √† partir du code postal
   */
  private getRegionFromPostalCode(codePostal: string): string {
    if (!codePostal) return 'Non sp√©cifi√©';
    
    const dept = codePostal.substring(0, 2);
    
    const regionMap: Record<string, string> = {
      '75': '√éle-de-France',
      '77': '√éle-de-France',
      '78': '√éle-de-France',
      '91': '√éle-de-France',
      '92': '√éle-de-France',
      '93': '√éle-de-France',
      '94': '√éle-de-France',
      '95': '√éle-de-France',
      '13': 'Provence-Alpes-C√¥te d\'Azur',
      '69': 'Auvergne-Rh√¥ne-Alpes',
      '59': 'Hauts-de-France',
      '33': 'Nouvelle-Aquitaine',
      '44': 'Pays de la Loire',
      '67': 'Grand Est',
      '31': 'Occitanie',
      '35': 'Bretagne',
      '76': 'Normandie',
      '21': 'Bourgogne-Franche-Comt√©',
      '34': 'Occitanie',
    };

    return regionMap[dept] || 'Autre r√©gion';
  }

  /**
   * Convertit le code de taille en libell√©
   */
  private getSizeLabel(trancheEffectifs?: string): string {
    if (!trancheEffectifs) return 'Non sp√©cifi√©';

    const sizeMap: Record<string, string> = {
      '00': 'Aucun salari√©',
      '01': 'Tr√®s petite (1-2)',
      '02': 'Tr√®s petite (3-5)',
      '03': 'Tr√®s petite (6-9)',
      '11': 'Petite (10-19)',
      '12': 'Petite (20-49)',
      '21': 'Moyenne (50-99)',
      '22': 'Moyenne (100-199)',
      '31': 'Grande (200-249)',
      '32': 'Grande (250-499)',
      '41': 'Tr√®s grande (500-999)',
      '42': 'Tr√®s grande (1000-1999)',
      '51': 'Tr√®s grande (2000-4999)',
      '52': 'Tr√®s grande (5000-9999)',
      '53': 'Tr√®s grande (10000+)',
    };

    return sizeMap[trancheEffectifs] || 'Taille inconnue';
  }
}

export const companyDataService = new CompanyDataService();
